<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topolog√≠a Desplegada</title>

    <!-- vis-network -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" rel="stylesheet">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f0f4f8 0%, #e8eef5 100%);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: white;
            padding: 18px 30px;
            border-bottom: 1px solid #e2e8f0;
            box-shadow: 0 2px 10px rgba(100, 116, 139, 0.08);
            z-index: 10;
        }

        .header h1 {
            color: #1e293b;
            font-size: 24px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slice-subtitle {
            color: #64748b;
            font-size: 14px;
            margin-top: 4px;
            font-weight: 400;
        }

        /* Main container */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Canvas */
        #topology-canvas {
            flex: 1;
            background: white;
            background-image:
                linear-gradient(rgba(148, 163, 184, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(148, 163, 184, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            position: relative;
        }

        /* Summary Panel */
        #summary-panel {
            width: 300px;
            background: white;
            border-left: 1px solid #e2e8f0;
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(100, 116, 139, 0.05);
        }

        .panel-section {
            padding: 16px;
            border-bottom: 1px solid #f1f5f9;
        }

        .panel-section h3 {
            color: #1e293b;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* VM Card compacta */
        .vm-card-compact {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .vm-card-compact:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
        }

        .vm-card-compact h4 {
            font-size: 13px;
            color: #1e293b;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .vm-specs {
            font-size: 11px;
            color: #64748b;
            line-height: 1.5;
        }

        /* Stats compact */
        .stats-compact {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-mini {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .stat-mini-value {
            font-size: 20px;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 2px;
        }

        .stat-mini-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;  /* Cambiar de absolute a fixed */
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 6px 0;
            min-width: 200px;
            z-index: 99999;  /* Aumentar z-index */
            display: none;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 13px;
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.15s;
        }

        .context-menu-item:hover {
            background: #f1f5f9;
        }

        .context-menu-item:active {
            background: #e2e8f0;
        }

        /* Footer */
        .footer {
            background: white;
            padding: 14px 24px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-secondary {
            background: #f1f5f9;
            color: #475569;
        }

        .btn-secondary:hover {
            background: #e2e8f0;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <h1 id="slice-name">üöÄ Cargando topolog√≠a...</h1>
        <div class="slice-subtitle" id="slice-subtitle">Estado: ...</div>
    </header>

    <!-- Main container -->
    <div class="main-container">
        <!-- Canvas -->
        <div id="topology-canvas" style="position: relative;"></div>

        <!-- Summary Panel -->
        <aside id="summary-panel">
            <!-- Info general -->
            <div class="panel-section">
                <h3>üìä Informaci√≥n</h3>
                <div class="stats-compact">
                    <div class="stat-mini">
                        <div class="stat-mini-value" id="total-vms">0</div>
                        <div class="stat-mini-label">VMs</div>
                    </div>
                    <div class="stat-mini">
                        <div class="stat-mini-value" id="total-vlans">0</div>
                        <div class="stat-mini-label">VLANs</div>
                    </div>
                </div>
            </div>

            <!-- VMs compactas -->
            <div class="panel-section">
                <h3>üñ•Ô∏è M√°quinas Virtuales</h3>
                <div id="vms-list"></div>
            </div>
        </aside>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <a href="/projects" class="btn btn-secondary">‚Üê Volver a Proyectos</a>
    </footer>

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" id="menu-terminal">
            <span>üñ•Ô∏è</span>
            <span>Abrir Terminal VNC</span>
        </div>
    </div>

    <script>
        const PC_IMAGE = '/static/images/pc.png';
        const sliceId = {{ slice_id }};
        let sliceData = null;
        let templateData = null;
        let network = null;
        let selectedVmId = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ P√°gina cargada, iniciando...');
            
            // Verificar que el men√∫ contextual existe
            const menu = document.getElementById('context-menu');
            console.log('üìã Men√∫ contextual encontrado:', menu);
            
            loadSliceData();
        });
        
        async function loadSliceData() {
            try {
                // 1. Cargar datos del slice desplegado (VMs reales, VLANs, VNC ports)
                const sliceResponse = await fetch(`/slices/${sliceId}/details`, {
                    credentials: 'include'
                });
                
                if (!sliceResponse.ok) throw new Error('Error al cargar slice');
                
                sliceData = await sliceResponse.json();
                console.log('Slice data:', sliceData);
                
                // 2. Cargar template para obtener la topolog√≠a (nodos y conexiones)
                if (!sliceData.template_id) {
                    throw new Error('Este slice no tiene template asociado');
                }
                
                const templateResponse = await fetch(`/templates/${sliceData.template_id}`, {
                    credentials: 'include'
                });
                
                if (!templateResponse.ok) throw new Error('Error al cargar template');
                
                templateData = await templateResponse.json();
                console.log('Template data:', templateData);
                
                if (!templateData.json_template || !templateData.json_template.topologia) {
                    throw new Error('El template no tiene topolog√≠a guardada');
                }
                
                // Actualizar header
                document.getElementById('slice-name').textContent = `üöÄ ${sliceData.name}`;
                document.getElementById('slice-subtitle').textContent = `Estado: ${sliceData.status} ¬∑ Creado: ${formatDate(sliceData.created_at)}`;
                
                // Actualizar stats
                const totalNodes = templateData.json_template.topologia.nodes.length;
                const totalEdges = templateData.json_template.topologia.edges.length;
                document.getElementById('total-vms').textContent = totalNodes;
                document.getElementById('total-vlans').textContent = sliceData.vlans.length;
                
                console.log(`Renderizando ${totalNodes} nodos y ${totalEdges} conexiones`);
                
                // Renderizar usando topolog√≠a del template + datos del slice
                initNetwork();
                renderVMsList();
                
            } catch (error) {
                console.error('Error:', error);
                alert('Error al cargar la topolog√≠a: ' + error.message);
            }
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return 'N/A';
            const d = new Date(dateStr);
            return d.toLocaleDateString('es-ES', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        }
        
        function buildNodeTitle(vmNode, recursos, publicAccess) {
            // vmNode es del template (vm-1, vm-2, etc)
            // recursos es del template.json_template.recursos
            const cfg = recursos[vmNode.id] || {};
            const hasInternet = publicAccess.includes(vmNode.id);
            
            // Buscar VM real desplegada por nombre
            const deployedVm = sliceData.vms.find(v => v.name === (cfg.name || vmNode.label || vmNode.id));
            const vncPort = deployedVm ? sliceData.vnc_ports.find(p => p.vm_id === deployedVm.vm_id) : null;
            
            let title = `${cfg.name || vmNode.label || vmNode.id}\n`;
            title += `Flavour: ${cfg.flavour || 'N/A'}\n`;
            title += `CPU: ${cfg.vcpu || cfg.cpu || 0}v | RAM: ${cfg.ram_gb || cfg.ram || 0}GB\n`;
            title += `Disco: ${cfg.disk_gb || cfg.disk || 0}GB\n`;
            title += `Imagen: ${cfg.os || cfg.image || 'N/A'}\n`;
            title += `Internet: ${hasInternet ? 'S√≠' : 'No'}`;
            
            if (deployedVm) {
                title += `\n\n--- Despliegue ---\n`;
                title += `Estado: ${deployedVm.status}\n`;
                if (deployedVm.worker_ip) {
                    title += `Worker: ${deployedVm.worker_ip}\n`;
                }
                if (vncPort) {
                    title += `Puerto VNC: ${vncPort.port_number}`;
                }
            }
            
            return title;
        }
        
        function initNetwork() {
            const container = document.getElementById('topology-canvas');
            const topoJSON = templateData.json_template;
            
            console.log('Topolog√≠a del template:', topoJSON.topologia);
            console.log('Nodos:', topoJSON.topologia.nodes);
            console.log('Conexiones:', topoJSON.topologia.edges);
            
            // Obtener lista de VMs con acceso a internet
            const publicAccess = (topoJSON.subred && topoJSON.subred.public_access) || [];
            
            // Crear mapa de vm_id del template a vm_id real desplegado
            const vmIdMap = {};
            topoJSON.topologia.nodes.forEach(node => {
                const cfg = topoJSON.recursos[node.id] || {};
                const deployedVm = sliceData.vms.find(v => v.name === (cfg.name || node.label || node.id));
                if (deployedVm) {
                    vmIdMap[node.id] = deployedVm.vm_id;
                }
            });
            
            // Crear nodos usando EXACTAMENTE la estructura del template
            const nodes = new vis.DataSet(
                topoJSON.topologia.nodes.map(node => {
                    const cfg = topoJSON.recursos[node.id] || {};
                    
                    return {
                        id: node.id,  // vm-1, vm-2, etc
                        label: `${cfg.name || node.label || node.id}\n${cfg.os || cfg.image || 'N/A'}`,
                        title: buildNodeTitle(node, topoJSON.recursos, publicAccess),
                        shape: "image",
                        image: node.image || PC_IMAGE,
                        x: node.x,
                        y: node.y,
                        fixed: false,
                        physics: false,
                        deployedVmId: vmIdMap[node.id]
                    };
                })
            );
            
            // Crear conexiones usando EXACTAMENTE los edges del template
            const edges = new vis.DataSet(
                topoJSON.topologia.edges.map(edge => ({
                    id: edge.id || `edge-${edge.from}-${edge.to}`,
                    from: edge.from,
                    to: edge.to,
                    color: { color: "#94a3b8", highlight: "#60a5fa" },
                    width: 2,
                    smooth: { type: "continuous" }
                }))
            );
            
            console.log(`Creando red con ${nodes.length} nodos y ${edges.length} aristas`);
            
            const data = { nodes, edges };
            
            const options = {
                nodes: {
                    shape: "image",
                    image: PC_IMAGE,
                    size: 40,
                    font: {
                        size: 13,
                        color: "#1e293b",
                        face: "Segoe UI",
                        background: "rgba(255, 255, 255, 0.9)",
                        strokeWidth: 0,
                        multi: true
                    },
                    borderWidth: 2,
                    borderWidthSelected: 3
                },
                edges: {
                    color: { color: "#94a3b8", highlight: "#60a5fa" },
                    width: 2,
                    smooth: { type: "continuous" }
                },
                physics: { enabled: false },
                interaction: {
                    dragNodes: true,
                    dragView: true,
                    zoomView: true,
                    selectable: true,
                    hover: true,
                    tooltipDelay: 150
                }
            };
            
            network = new vis.Network(container, data, options);
            
            console.log('üåê Red vis.js inicializada');
            
            // Click derecho en VM - usar rightClick en lugar de oncontext
            network.on('oncontext', function(params) {
                params.event.preventDefault();
                console.log('üñ±Ô∏è Click derecho detectado', params);
                
                const nodeId = network.getNodeAt(params.pointer.DOM);
                console.log('üìç Node ID:', nodeId);
                
                if (nodeId) {
                    const node = nodes.get(nodeId);
                    console.log('üì¶ Node data:', node);
                    
                    if (node && node.deployedVmId) {
                        selectedVmId = node.deployedVmId;
                        console.log('‚úÖ VM seleccionada ID:', selectedVmId);
                        
                        // Usar las coordenadas del evento del DOM
                        const x = params.event.pageX || params.event.clientX;
                        const y = params.event.pageY || params.event.clientY;
                        console.log('üìç Mostrando men√∫ en:', x, y);
                        
                        showContextMenu(x, y);
                    } else {
                        console.log('‚ùå Nodo sin deployedVmId:', node);
                    }
                } else {
                    console.log('‚ùå No hay nodo en esta posici√≥n');
                }
            });
            
            console.log('‚úÖ Event listener de click derecho registrado');
            
            // TAMBI√âN agregar evento al canvas directamente como respaldo
            const canvas = document.getElementById('topology-canvas');
            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                console.log('üéØ Click derecho directo en canvas!', e);
                
                // Mostrar men√∫ de prueba
                showContextMenu(e.pageX, e.pageY);
                
                return false;
            });
            console.log('‚úÖ Event listener directo en canvas registrado');
            
            // Cerrar men√∫ al hacer click fuera
            document.addEventListener('click', hideContextMenu);
        }
        
        function renderVMsList() {
            const container = document.getElementById('vms-list');
            container.innerHTML = '';
            
            if (!templateData || !templateData.json_template) return;
            
            const topoJSON = templateData.json_template;
            const publicAccess = (topoJSON.subred && topoJSON.subred.public_access) || [];
            
            // Renderizar TODAS las VMs del template
            topoJSON.topologia.nodes.forEach(node => {
                const cfg = topoJSON.recursos[node.id] || {};
                const deployedVm = sliceData.vms.find(v => v.name === (cfg.name || node.label || node.id));
                const vncPort = deployedVm ? sliceData.vnc_ports.find(p => p.vm_id === deployedVm.vm_id) : null;
                const hasInternet = publicAccess.includes(node.id);
                
                const card = document.createElement('div');
                card.className = 'vm-card-compact';
                card.onclick = () => {
                    if (network) {
                        network.selectNodes([node.id]);
                        network.focus(node.id, { scale: 1.2, animation: true });
                    }
                };
                
                const statusText = deployedVm ? `<strong>${deployedVm.status}</strong>` : '<em style="color: #94a3b8;">No desplegada</em>';
                const vncText = vncPort ? `<br>VNC: ${vncPort.port_number}` : '';
                
                card.innerHTML = `
                    <h4>${cfg.name || node.label || node.id}</h4>
                    <div class="vm-specs">
                        <strong>${cfg.flavour || 'N/A'}</strong><br>
                        ${cfg.vcpu || cfg.cpu || 0}v ¬∑ ${cfg.ram_gb || cfg.ram || 0}GB ¬∑ ${cfg.disk_gb || cfg.disk || 0}GB<br>
                        ${cfg.os || cfg.image || 'N/A'}<br>
                        Internet: ${hasInternet ? '‚úì' : '‚úó'}<br>
                        Estado: ${statusText}${vncText}
                    </div>
                `;
                
                container.appendChild(card);
            });
            
            console.log(`Renderizadas ${topoJSON.topologia.nodes.length} VMs en el panel`);
        }
        
        function showContextMenu(x, y) {
            const menu = document.getElementById('context-menu');
            console.log('üìã Mostrando men√∫ en posici√≥n:', x, y);
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
            console.log('‚úÖ Men√∫ mostrado, display:', menu.style.display);
        }
        
        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
        }
        
        function getSSHPortFromWorkerIP(workerIP) {
            if (!workerIP) return null;
            
            // Extraer √∫ltimo octeto del worker_ip (10.20.201.1 -> 1)
            const parts = workerIP.split('.');
            const lastOctet = parts[parts.length - 1];
            
            // 201.1 -> 5811, 201.2 -> 5812, 201.3 -> 5813
            if (lastOctet === '1') return 5811;
            if (lastOctet === '2') return 5812;
            if (lastOctet === '3') return 5813;
            
            return null;
        }
        
        // Abrir terminal VNC
        document.getElementById('menu-terminal').addEventListener('click', function() {
            console.log('üñ±Ô∏è Click en menu-terminal, selectedVmId:', selectedVmId);
            if (!selectedVmId) {
                console.log('‚ùå No hay VM seleccionada');
                hideContextMenu();
                return;
            }
            
            hideContextMenu();
            
            const vncUrl = `/vnc/${selectedVmId}`;
            console.log('üöÄ Abriendo VNC viewer:', vncUrl);
            
            // Abrir VNC viewer en nueva pesta√±a
            window.open(vncUrl, '_blank');
        });
        
        console.log('‚úÖ Event listener de menu-terminal registrado');
    </script>
</body>
</html>
